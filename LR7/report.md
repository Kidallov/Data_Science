# Практическая работа: Основы рекомендательных систем

## Выполнил: Кидалов Александр Александрович, группа 1.2

## Задание №1. Контентная фильтрация (Content-Based Filtering)

#### **Код для контентной фильтрации представлен в `content_based_filtering.py`**

#### Результаты выполнения кода

```
Матрица Признаков:
          Action  Comedy  Drama  Sci-Fi
Film_ID                               
1             1       0      0       0
2             0       0      0       1
3             0       0      1       0
4             1       1      0       1
5             0       0      1       0

==================================================

Матрица Косинусного Сходства:

Title                    Die Hard  ...  La La Land
Title                              ...            
Die Hard                   1.0000  ...         0.0
The Martian                0.0000  ...         0.0
Pulp Fiction               0.0000  ...         1.0
Guardians of the Galaxy    0.5774  ...         0.0
La La Land                 0.0000  ...         1.0

[5 rows x 5 columns]

==================================================

Рекомендации для 'Die Hard':
                     Фильм  Сходство
0  Guardians of the Galaxy    0.5774
1              The Martian    0.0000

==================================================

Рекомендации для 'Pulp Fiction':
        Фильм  Сходство
0  La La Land       1.0
1    Die Hard       0.0

==================================================

Рекомендации для 'The Martian':
                     Фильм  Сходство
0  Guardians of the Galaxy    0.5774
1                 Die Hard    0.0000

==================================================

Рекомендации для 'La La Land':
        Фильм  Сходство
0  La La Land       1.0
1    Die Hard       0.0

==================================================

Полная матрица косинусного сходства для анализа:
Title                    Die Hard  ...  La La Land
Title                              ...            
Die Hard                   1.0000  ...         0.0
The Martian                0.0000  ...         0.0
Pulp Fiction               0.0000  ...         1.0
Guardians of the Galaxy    0.5774  ...         0.0
La La Land                 0.0000  ...         1.0

[5 rows x 5 columns]
```

### Ответы на вопросы для задания №1

#### 1. Какое сходство (число) система рассчитала между фильмами "The Martian" и "Guardians of the Galaxy"? Объясните, почему.

**Сходство:** 0.5774 (около 0.58)

**Объяснение:**
Фильмы сравниваются по вектору из 4 жанров:
- "The Martian": [0, 0, 0, 1] (только Sci-Fi)
- "Guardians of the Galaxy": [1, 1, 0, 1] (Action, Comedy, Sci-Fi)

Для расчета косинусного сходства:
1. Вычисляем скалярное произведение векторов: (0×1) + (0×1) + (0×0) + (1×1) = 1
2. Вычисляем нормы векторов:
   - Норма "The Martian": √(0² + 0² + 0² + 1²) = 1
   - Норма "Guardians of the Galaxy": √(1² + 1² + 0² + 1²) = √3 ≈ 1.732
3. Косинусное сходство = скалярное произведение / (норма₁ × норма₂) = 1 / (1 × 1.732) ≈ 0.577

Сходство не равно 1, потому что фильмы не идентичны по жанровому составу, но имеют общий жанр Sci-Fi.

#### 2. Какой главный недостаток Content-Based фильтрации вы видите на примере фильма "La La Land"?

**Главный недостаток:** Ограниченность рекомендаций только похожими по контенту объектами (фильмами того же жанра).

**Анализ на примере "La La Land":**
- "La La Land" имеет жанровый вектор: [0, 0, 1, 0] (только Drama)
- "Pulp Fiction" имеет жанровый вектор: [0, 0, 1, 0] (только Drama)
- Косинусное сходство = 1.0 (идеальное совпадение)

**Проблема:**
1. **Система рекомендует только фильмы того же жанра** — пользователю, посмотревшему драму "La La Land", будут рекомендованы только другие драмы, даже если ему могут понравиться качественные фильмы других жанров.
2. **Отсутствие разнообразия** — пользователь получает однотипные рекомендации.
3. **Невозможность открытия новых интересов** — система не может "угадать", что пользователю, которому понравилась музыкальная драма "La La Land", может также понравиться качественная комедия или фантастика.
4. **"Проклятие сходства"** — если в базе мало фильмов определённого жанра (например, только 2 драмы), то система будет постоянно рекомендовать одни и те же фильмы.

---

## Задание 2. Коллаборативная фильтрация (User-Based CF)

### Код для коллаборативной фильтрации

```python
from surprise import Dataset, Reader
from surprise import KNNWithMeans
from surprise.model_selection import train_test_split
from surprise import accuracy
import time

# 1. Загрузка данных MovieLens 100k
print("="*60)
print("ЗАГРУЗКА ДАННЫХ MOVIELENS 100K")
print("="*60)

# Reader нужен, чтобы указать диапазон оценок (от 1 до 5)
data = Dataset.load_builtin('ml-100k')

# Разделение данных на обучающую и тестовую выборки (80% на 20%)
trainset, testset = train_test_split(data, test_size=0.2, random_state=42)

print(f"Общее количество оценок в наборе данных: 100,000")
print(f"Размер обучающей выборки: {trainset.n_ratings} оценок")
print(f"Размер тестовой выборки: {len(testset)} оценок")
print(f"Количество пользователей: {trainset.n_users}")
print(f"Количество фильмов: {trainset.n_items}")
print("\n" + "="*60 + "\n")

# 2. Настройка и обучение модели User-Based CF с корреляцией Пирсона
print("ОБУЧЕНИЕ МОДЕЛИ USER-BASED CF (ПИРСОН)")
print("="*60)

# Используем корреляцию Пирсона (pearson) и User-Based подход
sim_options_pearson = {
    'name': 'pearson',
    'user_based': True,  # User-Based Collaborative Filtering
    'min_support': 3     # Минимальное количество общих оценок
}

# Инициализация алгоритма
algo_pearson = KNNWithMeans(
    k=40,                # Количество соседей
    min_k=2,             # Минимальное количество соседей
    sim_options=sim_options_pearson,
    verbose=False
)

# Обучение модели
start_time = time.time()
algo_pearson.fit(trainset)
training_time = time.time() - start_time

print(f"Модель User-Based CF (Пирсон) обучена за {training_time:.2f} секунд")
print(f"Количество соседей: {algo_pearson.k}")
print(f"Минимальное количество соседей: {algo_pearson.min_k}")
print("\n" + "="*60 + "\n")

# 3. Оценка качества модели (Пирсон)
print("ОЦЕНКА КАЧЕСТВА МОДЕЛИ (ПИРСОН)")
print("="*60)

# Предсказание на тестовой выборке
start_time = time.time()
predictions_pearson = algo_pearson.test(testset)
prediction_time = time.time() - start_time

# Расчет метрик
rmse_pearson = accuracy.rmse(predictions_pearson, verbose=False)
mae_pearson = accuracy.mae(predictions_pearson, verbose=False)

print(f"Время предсказания: {prediction_time:.2f} секунд")
print(f"RMSE (Среднеквадратичная ошибка): {rmse_pearson:.4f}")
print(f"MAE (Средняя абсолютная ошибка): {mae_pearson:.4f}")
print(f"Количество предсказаний: {len(predictions_pearson)}")

# Анализ распределения ошибок
errors = [abs(pred.r_ui - pred.est) for pred in predictions_pearson[:1000]]
print(f"Средняя ошибка (первые 1000): {sum(errors)/len(errors):.4f}")
print(f"Максимальная ошибка: {max(errors):.4f}")
print(f"Минимальная ошибка: {min(errors):.4f}")

# 4. Сравнение с косинусным сходством
print("\n" + "="*60)
print("СРАВНЕНИЕ: ПИРСОН VS КОСИНУСНОЕ СХОДСТВО")
print("="*60)

# Модель с косинусным сходством
sim_options_cosine = {
    'name': 'cosine',
    'user_based': True,
    'min_support': 3
}

algo_cosine = KNNWithMeans(
    k=40,
    min_k=2,
    sim_options=sim_options_cosine,
    verbose=False
)

algo_cosine.fit(trainset)
predictions_cosine = algo_cosine.test(testset)
rmse_cosine = accuracy.rmse(predictions_cosine, verbose=False)

print(f"RMSE с корреляцией Пирсона: {rmse_pearson:.4f}")
print(f"RMSE с косинусным сходством: {rmse_cosine:.4f}")
print(f"Разница: {abs(rmse_pearson - rmse_cosine):.4f}")
print("\n" + "="*60 + "\n")

# 5. Предсказание оценки для конкретного пользователя
print("ПРЕДСКАЗАНИЕ ОЦЕНКИ ДЛЯ КОНКРЕТНОГО ПОЛЬЗОВАТЕЛЯ")
print("="*60)

user_id = '196'
item_id = '302'  # Фильм "L.A. Confidential"

# Получение предсказания
prediction = algo_pearson.predict(user_id, item_id, verbose=False)

print(f"Пользователь ID: {user_id}")
print(f"Фильм ID: {item_id} ('L.A. Confidential')")
print(f"Предсказанная оценка: {prediction.est:.3f} / 5.0")

# Примеры других предсказаний
print("\nДополнительные примеры предсказаний:")

test_cases = [
    ('196', '50'),    # User 196, Item 50
    ('196', '181'),   # User 196, Item 181
    ('100', '302'),   # User 100, Item 302
    ('100', '50'),    # User 100, Item 50
]

for uid, iid in test_cases:
    pred = algo_pearson.predict(uid, iid, verbose=False)
    print(f"User {uid}, Item {iid}: {pred.est:.3f} / 5.0")

print("\n" + "="*60)
```

### Результаты выполнения кода

```
============================================================
ЗАГРУЗКА ДАННЫХ MOVIELENS 100K
============================================================
Общее количество оценок в наборе данных: 100,000
Размер обучающей выборки: 80000 оценок
Размер тестовой выборки: 20000 оценок
Количество пользователей: 943
Количество фильмов: 1682

============================================================

============================================================
ОБУЧЕНИЕ МОДЕЛИ USER-BASED CF (ПИРСОН)
============================================================
Модель User-Based CF (Пирсон) обучена за 1.58 секунд
Количество соседей: 40
Минимальное количество соседей: 2

============================================================

============================================================
ОЦЕНКА КАЧЕСТВА МОДЕЛИ (ПИРСОН)
============================================================
Время предсказания: 0.45 секунд
RMSE (Среднеквадратичная ошибка): 0.9512
MAE (Средняя абсолютная ошибка): 0.7481
Количество предсказаний: 20000
Средняя ошибка (первые 1000): 0.7483
Максимальная ошибка: 4.0000
Минимальная ошибка: 0.0000

============================================================
СРАВНЕНИЕ: ПИРСОН VS КОСИНУСНОЕ СХОДСТВО
============================================================
RMSE с корреляцией Пирсона: 0.9512
RMSE с косинусным сходством: 0.9578
Разница: 0.0066

============================================================

============================================================
ПРЕДСКАЗАНИЕ ОЦЕНКИ ДЛЯ КОНКРЕТНОГО ПОЛЬЗОВАТЕЛЯ
============================================================
Пользователь ID: 196
Фильм ID: 302 ('L.A. Confidential')
Предсказанная оценка: 4.095 / 5.0

Дополнительные примеры предсказаний:
User 196, Item 50: 4.204 / 5.0
User 196, Item 181: 3.936 / 5.0
User 100, Item 302: 3.674 / 5.0
User 100, Item 50: 3.718 / 5.0

============================================================
```

### Ответы на вопросы для отчета (Задание 2)

#### 1. Что означает полученное вами значение RMSE? Если бы RMSE было равно 0.5, а не полученному вами значению, что бы это значило для точности предсказаний?

**Полученное значение RMSE:** 0.9512

**Интерпретация:**
- RMSE (Root Mean Square Error) = 0.9512 означает, что в среднем предсказания модели отличаются от реальных оценок на примерно 0.95 балла по шкале от 1 до 5.
- Это означает, что если пользователь поставил фильму оценку 4, модель может предсказать оценку в диапазоне примерно 3.05-4.95.
- Такая точность является типичной для простых методов коллаборативной фильтрации на данных MovieLens 100k.

**Сравнение с RMSE = 0.5:**
- Если бы RMSE было равно 0.5, это означало бы **значительно более высокую точность** предсказаний.
- Ошибка предсказаний уменьшилась бы примерно вдвое (с 0.95 до 0.5).
- При RMSE = 0.5, если пользователь поставил оценку 4, модель предсказывала бы в диапазоне 3.5-4.5, что гораздо точнее.
- Это соответствовало бы уровню современных продвинутых рекомендательных систем.

**Контекст точности:**
- RMSE < 1.0 считается хорошим результатом для рекомендательных систем
- RMSE < 0.9 считается очень хорошим результатом
- RMSE < 0.8 считается отличным результатом
- RMSE = 0.95, полученное в работе, является стандартным базовым результатом для User-Based CF

#### 2. Как изменится значение RMSE, если в настройках sim_options заменить 'pearson' на 'cosine' (Косинусное сходство)? Объясните, почему Пирсон часто дает лучший результат, чем Косинусное сходство, в контексте оценок пользователей.

**Результаты сравнения:**
- RMSE с корреляцией Пирсона: 0.9512
- RMSE с косинусным сходством: 0.9578
- Разница: 0.0066 (Пирсон дает лучший результат)

**Почему Пирсон лучше, чем косинусное сходство:**

1. **Учет смещения пользователей (bias):**
   - Косинусное сходство сравнивает векторы "как есть"
   - Корреляция Пирсона сначала центрирует оценки (вычитает среднее пользователя)
   - Это важно, так как разные пользователи имеют разные "шкалы оценок":
     - Строгий пользователь: редко ставит 5, обычно 2-3
     - Добрый пользователь: часто ставит 4-5, редко 1-2

2. **Пример:**
   - Пользователь A: средняя оценка = 2.0, оценил фильм X как 3.0
   - Пользователь B: средняя оценка = 4.0, оценил фильм X как 5.0
   - Косинусное сходство: 3 ≠ 5 → низкое сходство
   - Корреляция Пирсона: (3-2)=1, (5-4)=1 → высокое сходство (оба оценили на 1 балл выше своего среднего)

3. **Устойчивость к индивидуальным предпочтениям:**
   - Пирсон корреляция игнорирует абсолютные значения оценок
   - Фокусируется на относительных паттернах: какие фильмы пользователь оценивает выше/ниже своего среднего
   - Это более точно отражает сходство вкусов

4. **Практический эффект:**
   - В рекомендательных системах важно не то, какие оценки ставят пользователи
   - Важно, какие фильмы они оценивают выше/ниже относительно своих собственных стандартов
   - Корреляция Пирсона лучше выявляет таких "смысловых соседей"

**Вывод:** Корреляция Пирсона обычно лучше подходит для рекомендательных систем, основанных на оценках пользователей, потому что она учитывает индивидуальные смещения в оценках и фокусируется на относительных предпочтениях.

---

## Сравнительный анализ подходов и выводы

### Сравнение Content-Based и User-Based CF

| Критерий | Content-Based Filtering | User-Based CF |
|----------|------------------------|---------------|
| **Принцип работы** | Рекомендации на основе сходства атрибутов объектов | Рекомендации на основе сходства пользователей |
| **Данные** | Атрибуты объектов (жанры, описания) | История оценок/взаимодействий пользователей |
| **"Холодный старт"** | Новые пользователи: проблема | Новые объекты: проблема |
| **Разнообразие** | Низкое (только похожие объекты) | Высокое (основано на вкусах похожих пользователей) |
| **Персонализация** | Ограниченная (на основе контента) | Высокая (на основе поведения) |
| **Пример из работы** | "La La Land" → "Pulp Fiction" (обе драмы) | User 196 → "L.A. Confidential" (4.095) |

### Вывод: Какой подход более перспективен для крупного онлайн-кинотеатра?

**Рекомендация: Гибридный подход, но с акцентом на User-Based CF**

**Аргументы:**

1. **Преимущества User-Based CF для онлайн-кинотеатра:**
   - **Открытие нового контента:** Может рекомендовать фильмы разных жанров, если похожие пользователи их высоко оценили
   - **Социальное измерение:** Учитывает "коллективную мудрость" сообщества
   - **Высокая персонализация:** Учитывает сложные паттерны поведения
   - **Эффективность для популярного контента:** Хорошо работает с фильмами, которые уже оценило много пользователей

2. **Недостатки Content-Based для кинотеатра:**
   - **Ограниченность:** Только рекомендации похожих фильмов
   - **Отсутствие разнообразия:** Пользователь может застрять в "жанровом пузыре"
   - **Сложность с новыми жанрами:** Не может рекомендовать фильмы в новых, неописанных жанрах

3. **Практические соображения:**
   - **Масштабируемость:** User-Based CF требует больших вычислительных ресурсов, но для крупного кинотеатра это оправдано
   - **Качество данных:** У кинотеатра есть богатая история просмотров и оценок
   - **Бизнес-цели:** User-Based CF лучше способствует открытию нового контента и увеличению вовлеченности

**Оптимальная стратегия:**
1. **Основная система:** User-Based Collaborative Filtering
2. **Дополнение:** Content-Based фильтрация для решения проблем "холодного старта" (новые пользователи, новые фильмы)
3. **Гибридный подход:** Комбинирование обоих методов для баланса между разнообразием и релевантностью

**Заключительный вывод:** Для крупного онлайн-кинотеатра User-Based Collaborative Filtering является более перспективным основным подходом, так как он лучше учитывает сложные паттерны пользовательских предпочтений и способствует открытию разнообразного контента, что критически важно для удержания пользователей и увеличения вовлеченности.
